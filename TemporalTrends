// ------------------------- UTILITY FUNCTIONS --------------------------------

// Append a tag to band names of an image
// Used to tag seasonal composites with a id tag
// inputs: image, string
// returns: image
function appendSeasonTag(im, tag) {
  var bands = im.bandNames();
  var tagged = bands.map(function(n) {
    return ee.String(n).cat('_').cat(tag);
  });
  return im.select(bands, tagged);
}

// Compute a season's composites (mean, max, min, max-min) in a year.
// Given a image collection for a year, split it into a 3 month season based on given mid month
// Compute composites and add a season id tag to the bands
// inputs: image collection (containing 1 year's images), season's mid month (ee.Date), string
// returns: image

function seasonalComposites(coll, seasonMidMonth, seasonTag) {
  var season = coll.filter(ee.Filter.date(seasonMidMonth.advance(-1, 'month'),
                                          seasonMidMonth.advance(+1, 'month')));
  var season_mean = appendSeasonTag(season.reduce(ee.Reducer.mean()), seasonTag);
  var season_max  = appendSeasonTag(season.reduce(ee.Reducer.max()),  seasonTag);
  var season_min  = appendSeasonTag(season.reduce(ee.Reducer.min()),  seasonTag);
  var season_maxMinusMin = appendSeasonTag(season.max().subtract(season.min()),
                                           'maxMinusMin_'+seasonTag);
  return ee.Image.cat(season_mean, season_max, season_min, season_maxMinusMin);
}

// Compute composites of all seasons, for each year in a list on the image collection
// Computed season by season, with each band-season as a separate band
// input: list of years, collection
// return: image collection
function yearlyComposites(years, coll) {
  return ee.ImageCollection.fromImages(years.map(function(y) {
    var djf_comps = seasonalComposites(coll, ee.Date.fromYMD(y, 1, 1), 'djf');
    var mam_comps = seasonalComposites(coll, ee.Date.fromYMD(y, 4, 1), 'mam');
    var jja_comps = seasonalComposites(coll, ee.Date.fromYMD(y, 7, 1), 'jja');
    var son_comps = seasonalComposites(coll, ee.Date.fromYMD(y, 10, 1), 'son');
    var ond_comps = seasonalComposites(coll, ee.Date.fromYMD(y, 11, 1), 'ond');
    
    return ee.Image.cat(djf_comps, mam_comps, jja_comps, son_comps, ond_comps)
             .set('system:time_start', ee.Date.fromYMD(y, 1, 1).millis(),
                  'year', y);
  }));
}

// Find list of years the collection has data for
// input: collection
// output: list
function extractYears(coll) {
  return ee.List(coll.aggregate_array('system:time_start'))
    .map(function(t) {return ee.Date(t).get('year')})
    .distinct();
}

// (Pre-)Append a constant and time band to an image
// Mapping this over an image collection prepares it for linear regression vs. time
// input: image
// output: image
function appendConstNTimeBands(im) {
    return ee.Image(1)
             .float() // to keep band data types consistent
             .addBands(im.metadata('system:time_start').divide(1e15)
                         .float() // to keep band data types consistent
                         .rename('time'))
             .addBands(im)
             .copyProperties(im, ['system:time_start', 'year']);
}

// Calculate monthly means of all bands of images in a collection.
// Sets a image property with number of bands -- can subsequently 
// be used to filter out months with no data.
// Used for data available at frequency greater than monthly 
// input: image collection, list of years, list of months
// output: image collection
function monthwiseAggregate(coll, years, months) {
  return ee.ImageCollection.fromImages(years.map(function(y) {
    return months.map(function(m) {
      var mOfyDate = ee.Date.fromYMD(y, m, 1);
      var mOfyAggr = coll.filterDate(mOfyDate, mOfyDate.advance(1, 'month'))
                         .mean();
      return mOfyAggr.set('system:time_start', mOfyDate.millis(),
                          'date', mOfyDate.format('YYYY-MM-dd'),
                          'numBands', mOfyAggr.bandNames().length());
    });
  }).flatten());
}

// ------------------------- PROCESSING -------------------------------------

// Find Uganda boundary and add buffer
var uganda = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')
  .filter(ee.Filter.eq('country_co', 'UG'))
  .aside(Map.addLayer)
  .first();
var ugandaBuffered = ee.Feature(uganda).buffer(3e5); // 300km buffer

// Get relevant FLDAS data
// More info:https://developers.google.com/earth-engine/datasets/catalog/NASA_FLDAS_NOAH01_C_GL_M_V001
var fldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001')
  .filter(ee.Filter.date('1982-01-01', '2018-12-31')) // 2019 is not yet complete
  // Select soil surface moisture, surface runoff, 
  // surface radiative temperature, near surface air temperature
  .select(['SoilMoi00_10cm_tavg', 'Qs_tavg', 'RadT_tavg', 'Tair_f_tavg']);

// Years for which data are available
var imYears = extractYears(fldas);

// Create time series of composites
var timeSeries = yearlyComposites(imYears, fldas)
  .aside(print, 'yearly composites')
  // add a constant and time band, in preparation of regression
  .map(appendConstNTimeBands)
  .aside(print, 'yearly composites, time & constant added');

var predVars = ee.Image(timeSeries.first()).bandNames()
  .slice(0, 2); // constant, time are predictor vars
var respVars = ee.Image(timeSeries.first()).bandNames()
  .slice(2);    // rest all are response vars

// Perform regression. All response variables handled at once.
var temporalRegr = timeSeries.reduce(ee.Reducer.linearRegression(predVars.size(), respVars.size()))
  .aside(print, 'regression output');

// Regression result (coefficients) is array image that must be flattened.
// These lists label the information along each axis of the arrays.
// From eg. at https://developers.google.com/earth-engine/reducers_regression
var bandNames = [predVars,  // 0-axis variation.
                 respVars]; // 1-axis variation.

// Flatten the array images to get all coefficients as bands,
// in a multi-band image according to the labels
// "time_*" bands are the slopes of the regression
// "constant_* bands are offsets of the regression
var regrCoeffs = temporalRegr.select(['coefficients']).arrayFlatten(bandNames)
  .aside(print, 'regression output flattened');

// ------------------------- DISPLAY & EXPORT -----------------------------------

// Displaying a coefficient image
var visParam = {"opacity":1,"bands":["time_SoilMoi00_10cm_tavg_mean_djf"], palette: ['red', 'grey', 'blue'],
  "min":-54.47085296630859,"max":54};
Map.addLayer(regrCoeffs.select('time_SoilMoi00_10cm_tavg_mean_djf').clip(ugandaBuffered),
  visParam, 'time_SoilMoi00_10cm_tavg_mean_djf');
Map.centerObject(ugandaBuffered);

// Find CRS and nominal scale of original images
print(ee.Image(fldas.first()).projection(), 'original projection');
var expCRS = ee.Image(fldas.first()).projection().crs().getInfo();
var expScl = ee.Image(fldas.first()).projection().nominalScale().getInfo();

// Export to drive
Export.image.toDrive({
  image: regrCoeffs.clip(ugandaBuffered),
  description: 'UgandaClimVarsRegr',
  fileNamePrefix: 'UgandaClimVarsRegr',
  region: ugandaBuffered.bounds(), 
  scale: expScl,
  crs: expCRS
});

////////////// Terra Climate ///////////////////

var terraClim = ee.ImageCollection('IDAHO_EPSCOR/TERRACLIMATE')
  .filter(ee.Filter.date('1979-01-01', '2018-12-31')) // 2018 not available
  .select(['aet', 'def', 'pdsi', 'pet', 'pr', 'ro', 'soil', 'tmmn', 'tmmx']);

var terraClimCRS = ee.Image(terraClim.first()).projection().crs().getInfo();
var terraClimScl = ee.Image(terraClim.first()).projection().nominalScale().getInfo();

// Years for which data are available
var terraClimYears = extractYears(terraClim);

// time series of composites
var terraClimTimeSeries = yearlyComposites(terraClimYears, terraClim)
  .map(appendConstNTimeBands);

var terraClimPredVars = ee.Image(terraClimTimeSeries.first()).bandNames()
  .slice(0, 2); // constant, time are predictor vars
var terraClimRespVars = ee.Image(terraClimTimeSeries.first()).bandNames()
  .slice(2);    // rest all are response vars

// Perform regression. All response variables handled at once.
var terraClimRegr = terraClimTimeSeries
  .reduce(ee.Reducer.linearRegression(terraClimPredVars.size(), terraClimRespVars.size()))
  .aside(print, 'terraClim regression output');

// Flatten regression result (coefficients) array image - band names
var terraClimRegrResBandNames = [terraClimPredVars,  // 0-axis variation.
                                 terraClimRespVars]; // 1-axis variation.

// Flatten the array images to get all coefficients as bands,
// in a multi-band image according to the labels
// "time_*" bands are the slopes of the regression
// "constant_* bands are offsets of the regression
var terraClimRegrCoeffs = terraClimRegr.select(['coefficients']).arrayFlatten(terraClimRegrResBandNames)
  .aside(print, 'terraClimregression output flattened');

// Export to drive
Export.image.toDrive({
  image: terraClimRegrCoeffs.clip(ugandaBuffered),
  description: 'UgandaTerraClimRegr',
  fileNamePrefix: 'UgandaTerraClimRegr',
  region: ugandaBuffered.bounds(), 
  scale: terraClimScl,
  crs: terraClimCRS
});

//////////////// GLDAS 2.1 ///////////////////////

var gldas = ee.ImageCollection('NASA/GLDAS/V021/NOAH/G025/T3H')
  .filter(ee.Filter.date('2000-01-01', '2018-12-31'))
  .select(['AvgSurfT_inst', 'Evap_tavg', 'PotEvap_tavg', 'Qs_acc', 'Qsb_acc', 
          'Rainf_f_tavg', 'RootMoist_inst', 'SoilMoi0_10cm_inst', 'Tveg_tavg']);
var gldasCRS = ee.Image(gldas.first()).projection().crs().getInfo();
var gldasScl = ee.Image(gldas.first()).projection().nominalScale().getInfo();

// Years for which data are available
var gldasYears = extractYears(gldas);
// Months in a year
var months = ee.List.sequence(1, 12);

var gldasMonthly = monthwiseAggregate(gldas, gldasYears, months);

// time series of composites
var gldasTimeSeries = yearlyComposites(gldasYears, gldasMonthly)
  .map(appendConstNTimeBands);

var gldasPredVars = ee.Image(gldasTimeSeries.first()).bandNames()
  .slice(0, 2); // constant, time are predictor vars
var gldasRespVars = ee.Image(gldasTimeSeries.first()).bandNames()
  .slice(2);    // rest all are response vars

// Perform regression. All response variables handled at once.
var gldasRegr = gldasTimeSeries
  .reduce(ee.Reducer.linearRegression(gldasPredVars.size(), gldasRespVars.size()))
  .aside(print, 'gldas regression output');

// Flatten regression result (coefficients) array image - band names
var gldasRegrResBandNames = [gldasPredVars,  // 0-axis variation.
                             gldasRespVars]; // 1-axis variation.

// Flatten the array images to get all coefficients as bands,
// in a multi-band image according to the labels
// "time_*" bands are the slopes of the regression
// "constant_* bands are offsets of the regression
var gldasRegrCoeffs = gldasRegr.select(['coefficients']).arrayFlatten(gldasRegrResBandNames)
  .aside(print, 'gldasregression output flattened');

// Export to drive
Export.image.toDrive({
  image: gldasRegrCoeffs.clip(ugandaBuffered),
  description: 'UgandaGldasRegr',
  fileNamePrefix: 'UgandaGldasRegr',
  region: ugandaBuffered.bounds(), 
  scale: gldasScl,
  crs: gldasCRS
});

////////////// Ocean Color SMI ///////////////////

var oceanSmi = ee.ImageCollection('NASA/OCEANDATA/MODIS-Aqua/L3SMI')
  .filter(ee.Filter.date('2003-01-01', '2018-12-31')) // the 16 full years data is available for
  .select(['chlor_a', 'poc']); // sst not available

var oceanSmiCRS = ee.Image(oceanSmi.first()).projection().crs().getInfo();
var oceanSmiScl = ee.Image(oceanSmi.first()).projection().nominalScale().getInfo();

// Years for which data are available
var oceanSmiYears = extractYears(oceanSmi);
// Months in a year
var months = ee.List.sequence(1, 12);

var oceanSmiMonthly = monthwiseAggregate(oceanSmi, oceanSmiYears, months);

// time series of composites
var oceanSmiTimeSeries = yearlyComposites(oceanSmiYears, oceanSmiMonthly)
  .map(appendConstNTimeBands);

var oceanSmiPredVars = ee.Image(oceanSmiTimeSeries.first()).bandNames()
  .slice(0, 2); // constant, time are predictor vars
var oceanSmiRespVars = ee.Image(oceanSmiTimeSeries.first()).bandNames()
  .slice(2);    // rest all are response vars

// Perform regression. All response variables handled at once.
var oceanSmiRegr = oceanSmiTimeSeries
  .reduce(ee.Reducer.linearRegression(oceanSmiPredVars.size(), oceanSmiRespVars.size()))
  .aside(print, 'oceanSmi regression output');

// Flatten regression result (coefficients) array image - band names
var oceanSmiRegrResBandNames = [oceanSmiPredVars,  // 0-axis variation.
                                oceanSmiRespVars]; // 1-axis variation.

// Flatten the array images to get all coefficients as bands,
// in a multi-band image according to the labels
// "time_*" bands are the slopes of the regression
// "constant_* bands are offsets of the regression
var oceanSmiRegrCoeffs = oceanSmiRegr.select(['coefficients']).arrayFlatten(oceanSmiRegrResBandNames)
  .aside(print, 'oceanSmiregression output flattened');

// Export to drive
Export.image.toDrive({
  image: oceanSmiRegrCoeffs.clip(ugandaBuffered),
  description: 'UgandaOceanSMIRegr',
  fileNamePrefix: 'UgandaOceanSMIRegr',
  region: ugandaBuffered.bounds(), 
  scale: oceanSmiScl,
  crs: oceanSmiCRS
});
